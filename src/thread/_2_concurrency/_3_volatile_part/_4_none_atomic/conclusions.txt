    关键字volatile主要使用的场合是在多个线程中可以感知实例变量被更改了，并且可以获得最新的值使用，
也就是用多线程读取共享变量时可以获得最新值使用。
    关键字volatile提示线程每次从共享内存中读取变量，而不是从私有内存中读取，这样就保证了同步数据的可见性。
但这里需要注意的是：如果修改实例变量中的数据，比如i++，也就是i=i+1，这样的操作其实并不是一个原子操作，
也就是非线程安全的。表达式i++的操作步骤分解如下：
    1)从内存中取出i的值；
    2)计算i的值；
    3)将i的值写到内存中。
    假如在第2步计算值的时候，另外一个线程也修改i的值，那么这个时候就会出现脏数据。
解决的办法其实就是使用synchronized关键字。所以说volatile本身并不处理数据的原子性，
而是强制对数据的读写即使影响到主内存的。
    用图来演示一下使用关键字volatile时出现非线程安全的原因。变量在内存中工作的过程如图volatile.png所示。

    由上，我么可以得出一下结论：
    1)read和load阶段：从主存复制变量到当前线程工作内存；
    2)use和assign阶段：执行代码，改变共享变量值；
    3)store和write阶段：用工作内存数据刷新驻村对应变量的值。

    在多线程环境中，use和assign是多次出现的，但这一操作并不是并不是原子性，也就是在read和load之后，
如果主内存count变量发生修改之后，线程工作内存中的值由于已经加载，不会产生对应的变化，
也即是私有内存和公共内存中的变量不同步，所以计算出来的结果会和预期不一样，也就出现了非线程安全问题。
    对于用volatile修饰的变量，JVM虚拟机知识保证从主内存加载到线程工作内存的值是最新的，
例如线程1和线程2在进行read和load的操作中，发现主内存中count的值都是5，那么都会加载这个最新的值。也就是说，
volatile关键字解决的是变量读时的可见性问题，但无法保证原子性，对于多个线程访问同一个实例变量还是需要加锁同步。